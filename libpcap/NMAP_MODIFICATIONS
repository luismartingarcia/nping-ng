o Included this file, renamed directory from libpcap-1.0.0 to libpcap.

o Applied this configure.in patch which removes a useless test which caused configure to
  fail on Solaris 9 (and other versions).  This was fixed by libpcap in SVN a year and a half
  ago but they haven't made a release since then. Details: 
  http://sourceforge.net/tracker/index.php?func=detail&aid=2224954&group_id=53067&atid=469577

--- configure.in        (revision 17039)
+++ configure.in        (working copy)
@@ -358,7 +358,6 @@
 #include <net/if.h>
 #include <linux/types.h>
        ])
-       AC_CHECK_HEADERS()
        AC_LBL_TPACKET_STATS
        AC_LBL_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI
        ;;

o Removed these files and directories:
  packaging/
  config.guess
  config.sub
  install-sh
  Win32
  msdos

o Added @CFLAGS@ to the CFLAGS definition in Makefile.in to pick up -g
  if configure determines that it is supported:

--- Makefile.in.orig	2009-11-04 11:35:44.000000000 -0700
+++ Makefile.in	2009-11-04 11:50:02.000000000 -0700
@@ -55,7 +55,7 @@
 PROG=libpcap
 
 # Standard CFLAGS
-CFLAGS = $(CCOPT) $(INCLS) $(DEFS)
+CFLAGS = @CFLAGS@ $(CCOPT) $(INCLS) $(DEFS)
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@

o Eliminated Lex/Yacc requirement and added the generated files:
  grammar.c
  scanner.c
  scanner.h
  tokdefs.h

--- Makefile.in.orig	2009-11-04 11:35:44.000000000 -0700
+++ Makefile.in	2009-11-04 11:46:43.000000000 -0700
@@ -55,21 +55,13 @@
 PROG=libpcap
 
 # Standard CFLAGS
-CFLAGS = $(CCOPT) $(INCLS) $(DEFS)
+CFLAGS = @CFLAGS@ $(CCOPT) $(INCLS) $(DEFS)
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 RANLIB = @RANLIB@
 
-#
-# Flex and bison allow you to specify the prefixes of the global symbols
-# used by the generated parser.  This allows programs to use lex/yacc
-# and link against libpcap.  If you don't have flex or bison, get them.
-#
-LEX = @V_LEX@
-YACC = @V_YACC@
-
 # Explicitly define compilation rule since SunOS 4's make doesn't like gcc.
 # Also, gcc does not remove the .o before forking 'as', which can be a
 # problem if you don't own the file but can write to the directory.
@@ -122,7 +114,7 @@
 TAGFILES = \
 	$(SRC) $(HDR) $(TAGHDR)
 
-CLEANFILES = $(OBJ) libpcap.a $(GENSRC) $(GENHDR) lex.yy.c
+CLEANFILES = $(OBJ) libpcap.a lex.yy.c
 
 MAN1 = pcap-config.1
 
@@ -313,6 +305,15 @@
 
 all: libpcap.a pcap-config
 
+# Inhibit implicit rule Make seems to have for using yacc/lex to
+# recompile new scanner.c/grammar.c -- we ship ones which we want to
+# use instead.
+grammar.c:
+	echo "Not rebuilding grammar.c"
+
+scanner.c:
+	echo "Not rebuilding scanner.c"
+
 libpcap.a: $(OBJ)
 	@rm -f $@
 	$(AR) rc $@ $(OBJ) $(LIBS)
@@ -344,22 +345,11 @@
 		-compatibility_version 1 \
 		-current_version `sed 's/[^0-9.].*$$//' $(srcdir)/VERSION`
 
-scanner.c: $(srcdir)/scanner.l
-	@rm -f $@
-	./runlex.sh $(LEX) -o$@ $<
-
 scanner.o: scanner.c tokdefs.h
 	$(CC) $(CFLAGS) -c scanner.c
 
 pcap.o: version.h
 
-tokdefs.h: grammar.c
-grammar.c: $(srcdir)/grammar.y
-	@rm -f grammar.c tokdefs.h
-	$(YACC) -d $<
-	mv y.tab.c grammar.c
-	mv y.tab.h tokdefs.h
-
 grammar.o: grammar.c
 	@rm -f $@
 	$(CC) $(CFLAGS) -Dyylval=pcap_lval -c grammar.c
--- configure.in.orig   2009-10-27 16:20:34.000000000 -0600
+++ configure.in        2009-10-27 16:14:32.000000000 -0600
@@ -848,24 +848,6 @@
 fi


-AC_LBL_LEX_AND_YACC(V_LEX, V_YACC, pcap_)
-if test "$V_LEX" = lex ; then
-# Some versions of lex can't handle the definitions section of scanner.l .
-# Try lexing it and complain if it can't deal.
-       AC_CACHE_CHECK([for capable lex], tcpdump_cv_capable_lex,
-               if lex -t scanner.l > /dev/null 2>&1; then
-                       tcpdump_cv_capable_lex=yes
-               else
-                       tcpdump_cv_capable_lex=insufficient
-               fi)
-       if test $tcpdump_cv_capable_lex = insufficient ; then
-               AC_MSG_ERROR([Your operating system's lex is insufficient to compile
- libpcap.  flex is a lex replacement that has many advantages, including
- being able to compile libpcap.  For more information, see
- http://www.gnu.org/software/flex/flex.html .])
-       fi
-fi
-
 #
 # Assume a.out/ELF convention for shared library names (".so"), and
 # V7/BSD convention for man pages (file formats in section 5,
@@ -1004,10 +986,8 @@
 AC_SUBST(V_DEFS)
 AC_SUBST(V_INCLS)
 AC_SUBST(V_LIBS)
-AC_SUBST(V_LEX)
 AC_SUBST(V_PCAP)
 AC_SUBST(V_FINDALLDEVS)
-AC_SUBST(V_YACC)
 AC_SUBST(SSRC)
 AC_SUBST(DYEXT)
 AC_SUBST(DAGLIBS)

o The following patch removes some code that apparently causes libpcap
  on Solaris to wait for 64K chunks before returning in some cases,
  regardless of the timeout values.  Problem report and original patch
  came from Ben Harris (bjh21(a)cam.ac.uk)

--- dlpisubs.c.orig     2009-10-27 10:24:45.000000000 -0600
+++ dlpisubs.c  2009-10-27 10:24:49.000000000 -0600
@@ -291,14 +291,6 @@
                }
        }

-       /* Set the chunk length. */
-       chunksize = CHUNKSIZE;
-       if (strioctl(p->fd, SBIOCSCHUNK, sizeof(chunksize), (char *)&chunksize)
-           != 0) {
-               pcap_stream_err("SBIOCSCHUNKP", errno, p->errbuf);
-               retv = -1;
-       }
-
        return (retv);
 }
 #endif /* HAVE_SYS_BUFMOD_H */

o Merged commit 43acbb77a8e0b3346b574b3e28793de2d6985e69 from 
  git://bpf.tcpdump.org/libpcap, whose log message is "Work around an
  annoying Snow Leopard BPF bug that causes sub-second timeouts not to
  work in 64-bit userland code (Snow Leopard's GCC builds 64-bit by
  default on 64-bit machines)."

Index: configure.in
===================================================================
--- configure.in	(revision 17348)
+++ configure.in	(revision 17349)
@@ -381,6 +381,19 @@
 		[define if the system supports zerocopy BPF])
 	    ],
 	    AC_MSG_RESULT(no))
+
+	    #
+	    # Check whether we have struct BPF_TIMEVAL.
+	    #
+	    AC_CHECK_TYPES(struct BPF_TIMEVAL,,,
+		[
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_IOCCOM_H
+#include <sys/ioccom.h>
+#endif
+#include <net/bpf.h>
+		    ])
 	;;
 
 dag)
Index: config.h.in
===================================================================
--- config.h.in	(revision 17348)
+++ config.h.in	(revision 17349)
@@ -128,6 +128,9 @@
 /* Define to 1 if you have the `strlcpy' function. */
 #undef HAVE_STRLCPY
 
+/* Define to 1 if the system has the type `struct BPF_TIMEVAL'. */
+#undef HAVE_STRUCT_BPF_TIMEVAL
+
 /* Define to 1 if the system has the type `struct ether_addr'. */
 #undef HAVE_STRUCT_ETHER_ADDR
 
Index: pcap-bpf.c
===================================================================
--- pcap-bpf.c	(revision 17348)
+++ pcap-bpf.c	(revision 17349)
@@ -1859,16 +1859,45 @@
 		 * XXX - is this seconds/nanoseconds in AIX?
 		 * (Treating it as such doesn't fix the timeout
 		 * problem described below.)
+		 *
+		 * XXX - Mac OS X 10.6 mishandles BIOCSRTIMEOUT in
+		 * 64-bit userland - it takes, as an argument, a
+		 * "struct BPF_TIMEVAL", which has 32-bit tv_sec
+		 * and tv_usec, rather than a "struct timeval".
+		 *
+		 * If this platform defines "struct BPF_TIMEVAL",
+		 * we check whether the structure size in BIOCSRTIMEOUT
+		 * is that of a "struct timeval" and, if not, we use
+		 * a "struct BPF_TIMEVAL" rather than a "struct timeval".
+		 * (That way, if the bug is fixed in a future release,
+		 * we will still do the right thing.)
 		 */
 		struct timeval to;
-		to.tv_sec = p->md.timeout / 1000;
-		to.tv_usec = (p->md.timeout * 1000) % 1000000;
-		if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {
-			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT: %s",
-			    pcap_strerror(errno));
-			status = PCAP_ERROR;
-			goto bad;
+#ifdef HAVE_STRUCT_BPF_TIMEVAL
+		struct BPF_TIMEVAL bpf_to;
+
+		if (IOCPARM_LEN(BIOCSRTIMEOUT) != sizeof(struct timeval)) {
+			bpf_to.tv_sec = p->md.timeout / 1000;
+			bpf_to.tv_usec = (p->md.timeout * 1000) % 1000000;
+			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&bpf_to) < 0) {
+				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
+				    "BIOCSRTIMEOUT: %s", pcap_strerror(errno));
+				status = PCAP_ERROR;
+				goto bad;
+			}
+		} else {
+#endif
+			to.tv_sec = p->md.timeout / 1000;
+			to.tv_usec = (p->md.timeout * 1000) % 1000000;
+			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {
+				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
+				    "BIOCSRTIMEOUT: %s", pcap_strerror(errno));
+				status = PCAP_ERROR;
+				goto bad;
+			}
+#ifdef HAVE_STRUCT_BPF_TIMEVAL
 		}
+#endif
 	}
 
 #ifdef _AIX

o Regenerated configure.
